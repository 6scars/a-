import heapq
import math


def read_grid(file_path):
    with open(file_path, 'r') as file:
        grid = [list(map(int, line.strip().split())) for line in file]
    return grid


class Node:
    def __init__(self, position, parent=None):
        self.position = position    # wiersz, kolumna
        self.parent = parent        # Rodzic do śledzenia ścieszki

        #koszty dla algorytmu
        self.g = 0
        self.h = 0
        self.f = 0

    def __lt__(self, other):
        return self.f < other.f




def get_neightbors(node, grid):
    neighbors = []
    directions = [(0,1),(1,0),(0,-1),(-1,0)]
    for direction in directions:
        row = node.position[0] + direction[0]
        col = node.position[1] + direction[1]

        if 0 <= row < len(grid) and 0 <= col  < len(grid[0]):
            if grid[row][col ] == 0 :
                neighbors.append((row,col))
    return neighbors


def heuristic(current, goal):
    return math.sqrt((current[0] - goal[0])**2 + (current[1] - goal[1])**2)


def reconstruction_path(current_node):
    path = []
    while current_node:
        path.append(current_node.position)
        current_node = current_node.parent
    return path[::-1]







def a_star(grid,start,goal):
    open_list = []
    closed_set = set()
    heapq.heappush(open_list, Node(start))


    while open_list:
        # wybiera najmniejszy koszt f
        current_node = heapq.heappop(open_list)

        if current_node.position == goal:
            return reconstruction_path(current_node)

        # dodaj do listy odwiedzonych
        closed_set.add(current_node.position)

        for neighbor_pos in get_neightbors(current_node, grid):
            if neighbor_pos in closed_set:
                continue
            neighbor_node = Node(neighbor_pos, current_node)
            neighbor_node.g = current_node.g + 1
            neighbor_node.h = heuristic(neighbor_pos, goal)
            neighbor_node.f = neighbor_node.g + neighbor_node.h

            if any(open_node.position == neighbor_node.position and open_node.f <= neighbor_node.f for open_node in open_list):
                continue

            heapq.heappush(open_list, neighbor_node)
    return []

# ////////////////////////////////////////////////////////////////////////


file_path = "C:/Users/1/Desktop/AstarPB/grid.txt"
grid = read_grid(file_path)
start = (len(grid)-1, 0)
goal = (0,len(grid[0])-1)

print(start, goal)
for i in grid:
    print(i)

if grid[start[0]][start[1]] != 0 or grid[goal[0]][goal[1]] != 0:
    print("start lub cel znajduje się na przeszkodzie")
    exit()

path = a_star(grid,start,goal)


if path:
    print("znaleziono ścieżkę:", path)
else:
    print("nie znaleziono ściezki")