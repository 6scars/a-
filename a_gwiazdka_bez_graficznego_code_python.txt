import heapq
import math
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import copy
import matplotlib
matplotlib.use("TkAgg")


def read_grid(file_path):
    with open(file_path, 'r') as file:
        grid = [list(map(int, line.strip().split())) for line in file]
    return grid


class Node:
    def __init__(self, position, parent=None):
        self.position = position    # wiersz, kolumna
        self.parent = parent        # Rodzic do śledzenia ścieżki

        # Koszty dla algorytmu
        self.g = 0
        self.h = 0
        self.f = 0

    def __lt__(self, other):
        return self.f < other.f


def get_neighbors(node, grid):
    neighbors = []
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    for direction in directions:
        row = node.position[0] + direction[0]
        col = node.position[1] + direction[1]

        if 0 <= row < len(grid) and 0 <= col < len(grid[0]):
            if grid[row][col] == 0:
                neighbors.append((row, col))
    return neighbors


def heuristic(current, goal):
    return math.sqrt((current[0] - goal[0])**2 + (current[1] - goal[1])**2)
    #return abs(current[0]-goal[0]) + abs(current[1] - goal[1])

def reconstruction_path(current_node):
    path = []
    while current_node:
        path.append(current_node.position)
        current_node = current_node.parent
    return path[::-1]


def a_star_with_animation(grid, start, goal, anim_frames):
    open_list = []
    closed_set = set()
    heapq.heappush(open_list, Node(start))

    # Tworzymy pustą mapę wizualizacji na podstawie siatki
    visual_grid = copy.deepcopy(grid)

    while open_list:
        current_node = heapq.heappop(open_list)

        # Zaznacz aktualny węzeł jako odkryty (zielony)
        visual_grid[current_node.position[0]][current_node.position[1]] = 0.3  # Zielony
        anim_frames.append(copy.deepcopy(visual_grid))

        if current_node.position == goal:
            path = reconstruction_path(current_node)
            for pos in path:
                visual_grid[pos[0]][pos[1]] = 1.0  # Biały - finalna ścieżka
                anim_frames.append(copy.deepcopy(visual_grid))
            return path

        closed_set.add(current_node.position)

        for neighbor_pos in get_neighbors(current_node, grid):
            if neighbor_pos in closed_set:
                continue
            neighbor_node = Node(neighbor_pos, current_node)
            neighbor_node.g = current_node.g + 1
            neighbor_node.h = heuristic(neighbor_pos, goal)
            neighbor_node.f = neighbor_node.g + neighbor_node.h

            if any(open_node.position == neighbor_node.position and open_node.f <= neighbor_node.f for open_node in open_list):
                continue

            heapq.heappush(open_list, neighbor_node)

            # Zaznacz sąsiedni węzeł jako "w kolejce" (szary)
            visual_grid[neighbor_pos[0]][neighbor_pos[1]] = 0.5  # Szary
            anim_frames.append(copy.deepcopy(visual_grid))

    return []


def visualize(grid, anim_frames, start, goal):
    fig, ax = plt.subplots()
    ax.set_title("Algorytm A* - Animacja kratka po kratce")
    im = ax.imshow(grid, cmap='cool', interpolation='nearest')

    def update(frame_idx):
        im.set_data(anim_frames[frame_idx])
        return [im]

    ani = animation.FuncAnimation(fig, update, frames=len(anim_frames),interval=0.1, repeat=False, blit=True)
    plt.show()


# ////////////////////////////////////////////////////////////////////////

file_path = "C:/Users/1/Desktop/AstarPB/grid.txt"
grid = read_grid(file_path)
start = (len(grid)-1, 0)
goal = (0, len(grid[0])-1)

if grid[start[0]][start[1]] != 0 or grid[goal[0]][goal[1]] != 0:
    print("Start lub cel znajduje się na przeszkodzie")
    exit()

# Dane do animacji
anim_frames = []

# Uruchom algorytm i animację
path = a_star_with_animation(grid, start, goal, anim_frames)

if path:
    print("Znaleziono ścieżkę:", path)
else:
    print("Nie znaleziono ścieżki")

# Wizualizacja
visualize(grid, anim_frames, start, goal)

#2 odzielne pliki konsolowa i animacji, w konsoli dwie mapy ,przed i po a trase, i current_node = heapq.heappop(open_list) ,zeby brał pierwszy w kolejce a nie ostatni


